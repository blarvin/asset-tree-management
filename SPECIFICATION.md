This project is to prototype an asset tree management app. The goal of the app is to provide a hierarchical view of physical assets such as buildings, vehicles, or industrial systems. 

The overideing deisgn philosophy is a recursive tree structure, where nodes represent assets and their sub-assets. The nodes are identical at every level, and can have any number of nodes as children. This is similar to a file tree, except the containers (nodes) also have a data card showing any number of properties of the node itself at that point. This is all done with a single component, the Tree Node component. 

A second goal is "self-construction", which means the users of the app create and edit the assets and their structure themselves. 

A third goal is modeless or in-situ editing, which means the users can edit the assets, their structure, and all data card properties without having to leave the tree view.


// TreeNode DB Schema
interface TreeNodeRecord {
  id: string;                    // Primary key, (UUID)
  nodeName: string;              // Display name
  nodeSubtitle: string;          // Subtitle, displayed below name
  parentId: string | null;       // Reference to parent (null for root)
  ancestorIdPath: string;        // Single string of all ancestor IDs, separated by "|"
  ancestorNamePath: string;      // Single string of all ancestor names, separated by "|"
  typeOf: string;                // Type classification
  description: string;           // Description
  hashTags: string[];            // Node categorization tags
  virtualParents: string[];      // Virtual parent references
  createdBy: string;             // Creator ID, type: userID    
  createdAt: EpochTimeStamp;     // Creation timestamp, generated by client
  updatedBy: string;             // Last updater ID, type: userID
  updatedAt: EpochTimeStamp;     // Last update timestamp, generated by client
  componentType: string;         // Component type, user selected at creation
  componentVersion: string;      // For feedback and debugging
  customProperties: Record<string, unknown>[];	   // Such as API source, API key, etc.
  nodeOrdering: number;          // Display order among siblings, probably won't be used for normal nodes
  dataFields: { [fieldId: string]: string }; // Store field IDs only, not the entire record
  subAssets: { [nodeId: string]: boolean }; // Just references, not full objects
}


// DataField DB Schema
interface DataFieldRecord {
  id: string;                    // Primary key (UUID)
  fieldName: string;             // Field name, usuallly displayed as label
  parentNodeId: string;          // Foreign key to TreeNode, (UUID)
  dataValue: any;                // The actual value, user entered, user editable
  typeOf: string;                // Field type, user entered, user editable (required)
  hashTags: string[];            // Data Field categorization tags, user entered
  createdBy: string;             // Creator ID, type: userID
  createdAt: EpochTimeStamp;     // Creation timestamp, generated by client
  updatedBy: string;             // Last updater ID, type: userID
  updatedAt: EpochTimeStamp;     // Last update timestamp, generated by client
  cardOrdering: number;          // Position on DataCard, user editable
  componentType: string;         // Component type, user selected at creation
  componentVersion: string;      // For feedback and debugging
  customProperties: Record<string, unknown>[];	   // Such as API source, API key, etc.
  isRequired: boolean;           // Whether the field is required
  isLocked: boolean;             // Whether the field is locked, set by user
  isEditable: boolean;           // Whether the field is editable
}